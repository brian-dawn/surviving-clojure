* Clojure: Survival Kit
** Scope / Plan
   * Overview of the language for an audience familiar with programming
   * Document organized in 3 sections:
     * Craft: talk about the tools and what kind of experience is programming in Clojure
     * Brick laying: talk about the fundamental concepts of the language and how to use them.
     * Architecture: focuses on the concepts for large-scale system programming
** Brick Laying
*** Data
**** Nil
**** Truthiness
     * Every value is `true` to `if`, except `false` and `nil`.
**** Primitive Data Types
***** Nil
***** Boolean
***** Symbols
***** Numbers
      Might not need to go into the details of each type of numbers.
****** Integers
****** Floating-point Numbers
****** Rationals
***** Keywords
***** Strings
***** Characters
**** Composite Data Types
     Use those instead of defining your own class with a collection of getters/setters.
***** Collections
****** Lists
****** Vectors
***** Maps
***** Sets
***** Sequence Interface
*** Verbs
**** Function calls
**** Function definitions
***** fn
****** multi-arity
***** defn
***** #()
**** Control structures
***** Scoping
****** vars / def
****** let / blocks
***** Recursion/Loops
***** Laziness
****** Sequences are lazy in Clojure
       (map (fn [] (println %) (inc %)) (range 10))
       will not print anything
******* doall/doseq
******* Vectors and Maps are verbs too
****** lazy-seq
**** filter/map/reduce
*** Immutability
    * An data structure is immutable if it cannot be changed after it has been created.
    * But the point of a data structure is to modify it as the program runs.
    * How do you program with immutable data structure?
    * Huge advantage for concurrency.
*** Java interroperability
    * 2 faces of Clojure: functional programming & "host symbiosis"
      * Java is a practical platform: mature, fast, widely deployed
    * You can use Java libraries directly in your Clojure projects
    * Clojure programmers do this every day.
    * Accessing static class members
    * Instantiate
    * Method calls
    * Setters
    * .. macro
    * doto
    * reify
    * deftype
*** Destructuring
**** With a vector
**** With a map
*** Mutability
    * See "Threading in Clojure"
*** Misc
**** :pre/:post conditions
**** metadata
** Architecture
*** Higher-order functions
**** A Clojure functions can be passed as an argument or returned by another function
**** Popular higher-order functions
***** comp
****** (def third (comp first rest rest))
***** partial
****** (def double (partial * 2))
***** complement
****** (filter (complement nil?) coll)
***** memoize
**** Short example with a parser combinator to demonstrate the power of higher-order functions
*** Closures
**** A function that closes over its environment.
**** TODO Find interesting example
*** Multi-methods
*** Protocols
*** Macros
** Gotchas / Idioms
*** when-let / if-let

*** (Boolean. "false") is true. Use (Boolean/valueOf "false") instead.
** Conclusion
   * The ideas behind Clojure are even more important than the language itself. Don't hesitate to steal!
   * Beginner's mind
     * Don't try to force your model of programming to the language.
     * Clojure is committed to dynamic systems
     * What is great with Clojure is that it gets obvious very quickly when you're misusing it.
       * Good Clojure programs are concise.
   * You still need to design your programs (decomposition, uniform interfaces...)
   * What we didn't talke about:
     * core.async
     * transducers
** References
   * [[https://aphyr.com/posts/301-clojure-from-the-ground-up-welcome][Kyle Kingsbury: Clojure from the ground up]]
   * Michael Fogus, Chris Houser: The Joy of Clojure
